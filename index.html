<!DOCTYPE html>
<html lang="zh">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Flood Fill Puzzle</title>
	<style>
		@media (max-width: 768px) {
			h1 {
				font-size: 20px;
			}

			#palette,
			#preview,
			#gameBoard,
			#message {
				padding: 0 10px;
			}
		}

		body {
			font-family: 'Segoe UI', 'Helvetica Neue', sans-serif;
			text-align: center;
			background-color: #dceef9;
			color: #2c3e50;
			transition: background 0.3s, color 0.3s;
			margin: 0;
			padding: 0;
			box-sizing: border-box;
			overflow-x: hidden;

			min-height: 100vh;
			display: flex;
			justify-content: center;
		}

		body.dark {
			background-color: #0c1a2b;
			color: #eee;
		}

		body.dark .cell {
			width: 8vw;
			height: 8vw;
			max-width: 30px;
			max-height: 30px;
			border: 1px solid #ccc;
			box-sizing: border-box;
			transition: background-color 0.2s;
		}


		body.dark .cell {
			outline-color: #eee !important;
		}

		select {
			margin: 4px;
			padding: 6px;
			border-radius: 6px;
			border: 1px solid #3498db;
			font-size: 14px;
			background: #e8f4fb;
			color: #2c3e50;
		}

		#preview img {
			display: none;
		}

		h1 {
			font-size: 36px;
			margin: 12px 0;
			letter-spacing: 1px;
		}

		select,
		button {
			font-size: 15px;
			padding: 6px 12px;
			margin: 6px;
			border-radius: 6px;
			border: none;
			background-color: #3498db;
			color: white;
			cursor: pointer;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
			transition: all 0.2s ease-in-out;
		}

		select:hover,
		button:hover {
			background-color: #2980b9;
			transform: translateY(-1px);
		}

		#levelSelect,
		#langSelect {
			text-align: center;
			background-color: #e8f4fb;
			color: #2c3e50;
			border: 1px solid #3498db;
		}

		#volume {
			vertical-align: middle;
			accent-color: #3498db;
		}

		#message {
			font-size: 18px;
			font-weight: bold;
			margin-top: 10px;
			min-height: 1.5em;
		}

		#hint {
			margin-top: 8px;
		}

		.hint-circle {
			display: inline-block;
			width: 14px;
			height: 14px;
			border-radius: 50%;
			margin: 0 4px;
			border: 1px solid #444;
		}

		#gameBoard {
			display: grid;
			gap: 2px;
			justify-content: center;
			margin: 10px auto;
			max-width: 90vw;
			padding: 10px;
			border-radius: 10px;
		}

		.cell {
			width: 30px;
			height: 30px;
			border: 1px solid #ccc;
			box-sizing: border-box;
			transition: background-color 0.2s;
		}

		#palette button {
			font-size: 14px;
			margin: 6px;
			border-radius: 50%;
			border: none;
			width: 30px;
			height: 30px;
			background: #3498db;
			color: white;
			cursor: pointer;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			transition: background 0.3s, transform 0.2s;
		}

		button:hover {
			background: #2980b9;
			transform: translateY(-1px);
		}

		#palette button:hover {
			transform: scale(1.1);
		}

		#palette button.selected {
			border: 3px solid #2c3e50;
			box-shadow: 0 0 5px #3498db;
		}

		body.dark #palette button.selected {
			border: 3px solid white;
		}

		.particle {
			position: absolute;
			width: 6px;
			height: 6px;
			border-radius: 50%;
			pointer-events: none;
			opacity: 1;
			animation: fadeOut 1.6s forwards;
			box-shadow: 0 0 6px 2px rgba(255, 255, 255, 0.6);
			filter: blur(0.5px);
		}

		@keyframes fadeOut {
			to {
				transform: translate(var(--dx), var(--dy));
				opacity: 0;
			}
		}

		.container {
			max-width: 500px;
			width: 100%;
			margin: auto;
			padding: 10px;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: flex-start;
			flex-grow: 0;
			height: auto;
			justify-content: flex-start;
		}

		.row {
			display: flex;
			justify-content: center;
			gap: 8px;
			margin: 1px 0;
			flex-wrap: wrap;
		}

		.row select,
		.row button,
		.row input[type="range"] {
			flex: 1;
			min-width: 120px;
			max-width: 150px;
			box-sizing: border-box;
		}
	</style>
	<link rel="manifest" href="manifest.json">
	<script>
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('service-worker.js').then(registration => {
					console.log('ServiceWorker registered:', registration);
				}).catch(error => {
					console.log('ServiceWorker registration failed:', error);
				});
			});
		}
	</script>
</head>

<body>
	<div class="container">
		<h1 id="gameTitle">Flood Fill Puzzle</h1>
		<div class="row">
			<select id="levelSelect" onchange="loadLevel(parseInt(this.value))"></select>
			<select id="langSelect" onchange="setLanguage(this.value)">
				<option value="">ÂàáÊèõË™ûË®Ä</option>
				<option value="zh-TW">ÁπÅÈ´î‰∏≠Êñá</option>
				<option value="zh-CN">ÁÆÄ‰Ωì‰∏≠Êñá</option>
				<option value="en">English</option>
				<option value="ja">Êó•Êú¨Ë™û</option>
			</select>
		</div>
		<div class="row">
			<button onclick="toggleMusic()">Èü≥Ê®ÇÈñãÈóú</button>
			<button onclick="toggleDarkMode()">ÊöóËâ≤Ê®°Âºè</button>
		</div>
		<div class="row">
			<button onclick="resetLevel()">ÈáçÊñ∞ÈñãÂßã</button>
			<button onclick="toggleHint()">È°ØÁ§∫ÊèêÁ§∫</button>
		</div>
		<audio id="bgm" src="./peaceful-piano-background-music-218762.mp3" loop autoplay></audio>
		<audio id="fillSound" src="ui-pop-sound-316482.mp3" preload="auto"></audio>
		<div id="preview"></div>
		<div id="palette"></div>
		<div id="gameBoard"></div>
		<div id="message"></div>
		<button id="installBtn"
			style="display: inline-block; position: fixed; bottom: 10px; right: 10px; z-index: 1000;">üì±ÂÆâË£ùÂà∞‰∏ªÁï´Èù¢</button>
	</div>
	<script>
		let levels = [];
		let currentGrid = [];
		let selectedColor = null;
		let start = [0, 0];
		let size = 0;
		let originalGrid = [];
		let currentLevelId = 1;
		let hintVisible = false;
		let usedMoves = 0;
		let isFilling = false;

		const SOUND_POOL_SIZE = 20;
		let fillSoundPool = [];

		function initSoundPool() {
			const baseSound = document.getElementById("fillSound");
			fillSoundPool = [];
			for (let i = 0; i < SOUND_POOL_SIZE; i++) {
				const sound = baseSound.cloneNode();
				sound.volume = baseSound.volume;
				fillSoundPool.push(sound);
				document.body.appendChild(sound);
			}
		}

		function playFillSound() {
			for (let i = 0; i < SOUND_POOL_SIZE; i++) {
				const sound = fillSoundPool[i];
				if (sound.paused || sound.ended) {
					sound.currentTime = 0;
					sound.play().catch(() => { });
					break;
				}
			}
		}


		async function loadLevels() {
			const res = await fetch("./flood_fill_levels.json");
			levels = await res.json();
			if (!localStorage.getItem("maxLevel")) {
				localStorage.setItem("maxLevel", "1");
			}
			renderLevelButtons();
			const autoLoadId = parseInt(localStorage.getItem("maxLevel") || "1");
			loadLevel(autoLoadId);
		}

		function renderLevelButtons() {
			const select = document.getElementById("levelSelect");
			const lang = localStorage.getItem('lang') || 'zh-TW';
			const t = translations[lang];
			select.innerHTML = '';
			const defaultOption = document.createElement("option");
			defaultOption.textContent = t.select;
			defaultOption.disabled = true;
			select.appendChild(defaultOption);
			const unlockedLevel = parseInt(localStorage.getItem("maxLevel") || "1");
			for (let level of levels) {
				const option = document.createElement("option");
				const unlockedLevel = parseInt(localStorage.getItem("maxLevel") || "1");
				if (level.id > unlockedLevel) {
					option.disabled = true;
					option.style.color = '#aaa';
				}
				option.value = level.id;
				if (lang === 'en') {
					option.textContent = `Level ${level.id}`;
				} else if (lang === 'ja') {
					option.textContent = `„É¨„Éô„É´${level.id}`;
				} else if (lang === 'zh-CN') {
					option.textContent = `Á¨¨ ${level.id} ÂÖ≥`;
				} else {
					option.textContent = `Á¨¨ ${level.id} Èóú`;
				}
				select.appendChild(option);
			}

			const maxLevel = parseInt(localStorage.getItem("maxLevel") || "1");
			select.value = maxLevel.toString();
		}

		function loadLevel(id) {
			const unlockedLevel = parseInt(localStorage.getItem("maxLevel") || "1");
			if (id > unlockedLevel) return;
			const level = levels.find(l => l.id === id);
			if (!level) return;

			currentLevelId = id;
			currentGrid = level.grid.map(row => [...row]);
			originalGrid = level.grid.map(row => [...row]);
			start = level.start;
			size = level.size;
			hintVisible = false;
			usedMoves = 0;

			const bestKey = `best_${level.id}`;
			const bestRecord = localStorage.getItem(bestKey);
			const bestText = bestRecord ? `ÔΩúÊúÄ‰Ω≥Ê≠•Êï∏Ôºö${bestRecord}` : "";

			const t = translations[localStorage.getItem('lang') || 'zh-TW'];
			document.getElementById("preview").innerHTML = `
        <h3>${t.nowLevel} ${level.id} ${t.nowLevel2}ÔΩú${level.size}x${level.size}ÔΩú${t.limitMove}: ${level.solution.length + 2} ${bestText}</h3>
        <p id="hint" style="display: none"></p>
        <p id="moveCount">${t.move}Ôºö0</p>
      `;


			renderPalette(level.colors);
			renderBoard();
			document.getElementById("message").textContent = "";
		}

		function renderHintCircles(sequence) {
			const hintContainer = document.getElementById("hint");
			hintContainer.innerHTML = `Ê≠•Êï∏Ôºö${sequence.length}<br>` + sequence.map(color => `<span class="hint-circle" style="background:${color}"></span>`).join('');
		}

		function toggleHint() {
			const hint = document.getElementById("hint");
			const level = levels.find(l => l.id === currentLevelId);
			if (!level) return;
			hintVisible = !hintVisible;
			if (hintVisible) {
				renderHintCircles(level.solution);
				hint.style.display = "block";
			} else {
				hint.style.display = "none";
			}
			renderBoard();
		}

		function resetLevel() {
			loadLevel(currentLevelId);
		}

		function renderPalette(colors) {
			const palette = document.getElementById("palette");
			palette.innerHTML = '';
			colors.forEach(color => {
				const btn = document.createElement("button");
				btn.style.backgroundColor = color;
				btn.className = selectedColor === color ? 'selected' : '';
				btn.onclick = () => {
					selectedColor = color;
					renderPalette(colors);
				};
				palette.appendChild(btn);
			});
		}

		function renderBoard() {
			const board = document.getElementById("gameBoard");
			board.innerHTML = '';
			board.style.gridTemplateColumns = `repeat(${size}, 30px)`;
			currentGrid.forEach((row, i) => {
				row.forEach((color, j) => {
					const cell = document.createElement("div");
					cell.className = 'cell';
					cell.style.backgroundColor = color;
					if (i === start[0] && j === start[1] && hintVisible) {
						cell.style.outline = '2px dashed black';
					} else {
						cell.style.outline = '';
					}
					cell.onclick = () => {
						if (isFilling || !selectedColor || currentGrid[i][j] === selectedColor) return;
						const level = levels.find(l => l.id === currentLevelId);
						usedMoves++;
						if (usedMoves > level.solution.length + 2) {
							document.getElementById("message").textContent = translations[localStorage.getItem('lang') || 'zh-TW'].failed;
							return;
						} else {
							document.getElementById("moveCount").textContent = `ÁõÆÂâçÊ≠•Êï∏Ôºö${usedMoves}`;
							isFilling = true;
							floodFill(i, j, currentGrid[i][j], selectedColor, () => {
								isFilling = false;
								renderBoard();
							});
						}
					};
					board.appendChild(cell);
				});
			});
		}

		async function floodFill(x, y, fromColor, toColor, onFinish) {
			if (fromColor === toColor || currentGrid[x][y] !== fromColor) return;
			const visited = Array.from({ length: size }, () => Array(size).fill(false));
			let queue = [[x, y]];
			visited[x][y] = true;
			const delayBase = 100;
			let step = 0;
			let frameCount = 0;
			const framesPerStep = 20;

			function processQueue() {
				frameCount++;
				if (frameCount < framesPerStep) {
					requestAnimationFrame(processQueue);
					return;
				}
				frameCount = 0;

				if (queue.length === 0) {
					if (onFinish) onFinish();
					return;
				}

				const nextQueue = [];
				for (const [cx, cy] of queue) {
					currentGrid[cx][cy] = toColor;
					renderBoard();
					createParticles(cx, cy, toColor);
					playFillSound();
					checkWin();

					const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
					for (const [dx, dy] of directions) {
						const nx = cx + dx;
						const ny = cy + dy;
						if (
							nx >= 0 && ny >= 0 && nx < size && ny < size &&
							!visited[nx][ny] && currentGrid[nx][ny] === fromColor
						) {
							visited[nx][ny] = true;
							nextQueue.push([nx, ny]);
						}
					}
				}

				step++;
				queue.length = 0;
				queue.push(...nextQueue);
				requestAnimationFrame(processQueue);
			}
			requestAnimationFrame(processQueue);
		}


		function checkWin() {
			const target = currentGrid[start[0]][start[1]];
			for (let i = 0; i < size; i++) {
				for (let j = 0; j < size; j++) {
					if (currentGrid[i][j] !== target) return;
				}
			}
			document.getElementById("message").textContent = translations[localStorage.getItem('lang') || 'zh-TW'].win;
			const currentId = currentLevelId;
			const prevMax = parseInt(localStorage.getItem("maxLevel") || "1");
			if (currentId >= prevMax) {
				localStorage.setItem("maxLevel", currentId + 1);
				renderLevelButtons();
			}
			const bestKey = `best_${currentId}`;
			const best = parseInt(localStorage.getItem(bestKey) || "999");
			if (usedMoves < best) {
				localStorage.setItem(bestKey, usedMoves);
				document.getElementById("message").textContent += translations[localStorage.getItem('lang') || 'zh-TW'].newRecord + usedMoves;
			}
			setTimeout(() => {
				if (levels.find(l => l.id === currentId + 1)) {
					loadLevel(currentId + 1);
				}
			}, 1000);
		}

		function createParticles(x, y, color) {
			const board = document.getElementById("gameBoard");
			const cells = board.querySelectorAll(".cell");
			const index = x * size + y;
			const cell = cells[index];
			if (!cell) return;

			const rect = cell.getBoundingClientRect();
			const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
			const scrollTop = window.scrollY || document.documentElement.scrollTop;
			const originX = rect.left + scrollLeft + rect.width / 2;
			const originY = rect.top + scrollTop + rect.height / 2;

			for (let i = 0; i < 4; i++) {
				const p = document.createElement("div");
				p.className = "particle";
				p.style.background = "white";
				p.style.boxShadow = `0 0 3px 2px ${color}`;
				const angle = Math.random() * 2 * Math.PI;
				const distance = 80 + Math.random() * 10;
				const dx = Math.cos(angle) * distance + "px";
				const dy = Math.sin(angle) * distance + "px";
				p.style.setProperty('--dx', dx);
				p.style.setProperty('--dy', dy);
				p.style.left = originX + 'px';
				p.style.top = originY + 'px';
				document.body.appendChild(p);
				setTimeout(() => p.remove(), 1600);
			}
		}

		loadLevels();
	</script>

	<script>
		const bgm = document.getElementById("bgm");
		bgm.volume = 0.5;
		function toggleMusic() {
			if (bgm.paused) bgm.play(); else bgm.pause();
		}
		function toggleDarkMode() {
			document.body.classList.toggle("dark");
		}
	</script>

	<script>
		let deferredPrompt;
		window.addEventListener('beforeinstallprompt', (e) => {
			e.preventDefault();
			deferredPrompt = e;
			document.getElementById('installBtn').style.display = 'inline-block';
		});

		document.getElementById('installBtn').addEventListener('click', async () => {
			const isIos = /iphone|ipad|ipod/i.test(window.navigator.userAgent);
			const isInStandaloneMode = 'standalone' in window.navigator && window.navigator.standalone;

			if (isIos && !isInStandaloneMode) {
				showIosInstallTip();
				return;
			}

			if (!deferredPrompt) return;
			deferredPrompt.prompt();
			const result = await deferredPrompt.userChoice;
			console.log('User response to A2HS:', result.outcome);
			deferredPrompt = null;
			document.getElementById('installBtn').style.display = 'none';
		});


		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.addEventListener('controllerchange', () => {
				const bar = document.createElement('div');
				bar.innerHTML = 'üîÑ ÁôºÁèæÊñ∞ÁâàÊú¨ÔºåË´ãÈªûÊ≠§ÈáçÊñ∞Êï¥ÁêÜ';
				bar.style.position = 'fixed';
				bar.style.bottom = '0';
				bar.style.width = '100%';
				bar.style.padding = '10px';
				bar.style.backgroundColor = '#333';
				bar.style.color = 'white';
				bar.style.textAlign = 'center';
				bar.style.cursor = 'pointer';
				bar.onclick = () => location.reload();
				document.body.appendChild(bar);
			});
		}

		const translations = {
			'zh-TW': {
				restart: 'ÈáçÊñ∞ÈñãÂßã', hint: 'È°ØÁ§∫ÊèêÁ§∫', dark: 'ÊöóËâ≤Ê®°Âºè', music: 'Èü≥Ê®ÇÈñãÈóú', select: 'Ë´ãÈÅ∏ÊìáÊÉ≥Áé©ÁöÑÈóúÂç°', nowLevel: 'Á¨¨', nowLevel2: 'Èóú', limitMove: 'ÈôêÂà∂Ê≠•Êï∏', move: 'ÁõÆÂâçÊ≠•Êï∏', best: 'ÊúÄ‰Ω≥Ê≠•Êï∏Ôºö', win: 'üéâ ÊÅ≠ÂñúÈÄöÈóúÔºÅ', newRecord: 'üåü Êñ∞Á¥ÄÈåÑÔºÅÊúÄ‰Ω≥Ê≠•Êï∏Ôºö', failed: '‚ùå Ë∂ÖÂá∫Ê≠•Êï∏ÈôêÂà∂ÔºåÊåëÊà∞Â§±ÊïóÔºÅ', iosTip: 'üì≤ Ë´ã‰ΩøÁî® Safari ÈªûÊìäÂàÜ‰∫´ÈÅ∏ÂñÆÔºåÁÑ∂ÂæåÈÅ∏Êìá„ÄéÂä†ÂÖ•‰∏ªÁï´Èù¢„ÄèÂç≥ÂèØÂÆâË£ùÊú¨ÈÅäÊà≤ÔºÅ'
			},
			'zh-CN': {
				install: 'Ê∑ªÂä†Âà∞‰∏ªÁï´Èù¢',
				restart: 'ÈáçÊñ∞ÂºÄÂßã', hint: 'ÊòæÁ§∫ÊèêÁ§∫', dark: 'Ê∑±Ëâ≤Ê®°Âºè', music: 'Èü≥‰πêÂºÄÂÖ≥', select: 'ËØ∑ÈÄâÊã©ÊÉ≥Áé©ÁöÑÂÖ≥Âç°', nowLevel: 'Á¨¨', nowLevel2: 'ÂÖ≥', limitMove: 'ÈôêÂà∂Ê≠•Êï∞', move: 'ÂΩìÂâçÊ≠•Êï∞', best: 'ÊúÄ‰Ω≥Ê≠•Êï∞Ôºö', win: 'üéâ ÊÅ≠ÂñúÈÄöÂÖ≥ÔºÅ', newRecord: 'üåü Êñ∞Á∫™ÂΩïÔºÅÊúÄ‰Ω≥Ê≠•Êï∞Ôºö', failed: '‚ùå Ë∂ÖÂá∫Ê≠•Êï∞ÈôêÂà∂ÔºåÊåëÊàòÂ§±Ë¥•ÔºÅ', iosTip: 'üì≤ ËØ∑‰ΩøÁî® Safari ÁÇπÂáªÂàÜ‰∫´ÊåâÈíÆÔºåÁÑ∂ÂêéÈÄâÊã©„ÄåÊ∑ªÂä†Âà∞‰∏ªÂ±èÂπï„Äç‰ª•ÂÆâË£ÖÊ∏∏ÊàèÔºÅ'
			},
			'en': {
				install: 'Install to Home Screen',
				restart: 'Restart', hint: 'Show Hint', dark: 'Dark Mode', music: 'Toggle Music', select: 'Select a level to play', nowLevel: 'Level', nowLevel2: '', limitMove: 'Moves limited', move: 'Moves used', best: 'Best: ', win: 'üéâ You Win!', newRecord: 'üåü New Record! Best: ', failed: '‚ùå Out of moves! Try again!', iosTip: 'üì≤ On Safari, tap the Share icon and choose ‚ÄúAdd to Home Screen‚Äù to install this game.'
			},
			'ja': {
				install: '„Éõ„Éº„É†ÁîªÈù¢„Å´ËøΩÂä†',
				restart: '„ÇÑ„ÇäÁõ¥„Åó', hint: '„Éí„É≥„ÉàË°®Á§∫', dark: '„ÉÄ„Éº„ÇØ„É¢„Éº„Éâ', music: 'Èü≥Ê•ΩÂàáÊõø', select: '„É¨„Éô„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ', nowLevel: '„É¨„Éô„É´', nowLevel2: '', limitMove: 'Âà∂Èôê„ÅÆÊâãÊï∞', move: 'ÁèæÂú®„ÅÆÊâãÊï∞', best: '„Éô„Çπ„ÉàÔºö', win: 'üéâ „ÇØ„É™„Ç¢ÔºÅ', newRecord: 'üåü Êñ∞Ë®òÈå≤ÔºÅ„Éô„Çπ„ÉàÔºö', failed: '‚ùå ÊâãÊï∞„Ç™„Éº„Éê„Éº„ÄÅÂ§±ÊïóÔºÅ', iosTip: 'üì≤ Safari„ÅßÂÖ±Êúâ„Ç¢„Ç§„Ç≥„É≥„Çí„Çø„ÉÉ„Éó„Åó„ÄÅ„Äå„Éõ„Éº„É†ÁîªÈù¢„Å´ËøΩÂä†„Äç„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
			}
		};

		function setLanguage(lang) {
			const langSelect = document.getElementById('langSelect');
			if (langSelect) langSelect.selectedIndex = 0;
			localStorage.setItem('lang', lang);
			applyLanguage();
		}

		function applyLanguage() {
			const titleMap = {
				'zh-TW': 'Â°´Ëâ≤ÈÅäÊà≤',
				'zh-CN': 'Â°´Ëâ≤Ê∏∏Êàè',
				'en': 'Flood Fill Puzzle',
				'ja': 'Â°ó„Çä„Å§„Å∂„Åó„Éë„Ç∫„É´'
			};
			const lang = localStorage.getItem('lang') || 'zh-TW';
			const t = translations[lang];
			const langSelect = document.getElementById('langSelect');
			if (langSelect) {
				langSelect.options[0].textContent = {
					'zh-TW': 'ÂàáÊèõË™ûË®Ä',
					'zh-CN': 'ÂàáÊç¢ËØ≠Ë®Ä',
					'en': 'Change Language',
					'ja': 'Ë®ÄË™û„ÇíÂ§âÊõ¥'
				}[lang];
			}
			document.querySelector('button[onclick="resetLevel()"]').textContent = t.restart;
			document.querySelector('button[onclick="toggleHint()"]').textContent = t.hint;
			document.querySelector('button[onclick="toggleDarkMode()"]').textContent = t.dark;
			document.querySelector('button[onclick="toggleMusic()"]').textContent = t.music;
			const titleEl = document.getElementById('gameTitle');
			if (titleEl) titleEl.textContent = titleMap[lang];
			const installBtn = document.getElementById('installBtn');
			if (installBtn) installBtn.innerHTML = 'üì± ' + (t.install || 'ÂÆâË£ùÂà∞‰∏ªÁï´Èù¢');
			const defaultOption = document.querySelector('#levelSelect option[disabled]');
			if (defaultOption) defaultOption.textContent = t.select;

			renderLevelButtons();

			if (typeof currentLevelId !== 'undefined' && levels.length > 0) {
				const level = levels.find(l => l.id === currentLevelId);
				if (level) {
					const bestKey = `best_${level.id}`;
					const bestRecord = localStorage.getItem(bestKey);
					const bestText = bestRecord ? `ÔΩú${t.best}${bestRecord}` : "";
					document.getElementById("preview").innerHTML = `
        <h3>${t.nowLevel} ${level.id} ${t.nowLevel2}ÔΩú${level.size}x${level.size}ÔΩú${t.limitMove}: ${level.solution.length + 2} ${bestText}</h3>
        <p id="hint" style="display: ${hintVisible ? 'block' : 'none'}"></p>
        <p id="moveCount">${t.move}Ôºö${usedMoves}</p>
      `;
					if (hintVisible) renderHintCircles(level.solution);
				}
			}
		}

		document.addEventListener('DOMContentLoaded', () => {
			const lang = localStorage.getItem('lang') || 'zh-TW';
			localStorage.setItem('lang', lang);
			applyLanguage();

			if (window.matchMedia('(display-mode: standalone)').matches) {
				document.getElementById('installBtn').style.display = 'none';
			}

			initSoundPool();
		});
	</script>
	<script>
		function showIosInstallTip() {
			const existing = document.getElementById("iosInstallTip");
			if (existing) return;

			const tip = document.createElement("div");
			tip.id = "iosInstallTip";
			tip.innerHTML = translations[localStorage.getItem('lang') || 'zh-TW'].iosTip;
			tip.style.padding = "10px";
			tip.style.color = document.body.classList.contains('dark') ? '#fff' : '#000';
			tip.style.background = document.body.classList.contains('dark') ? '#1e1e1e' : '#ffffe0';
			tip.style.border = document.body.classList.contains('dark') ? '1px solid #666' : '1px solid #aaa';
			tip.style.margin = "10px";
			tip.style.fontSize = "0.9em";
			tip.style.position = "fixed";
			tip.style.bottom = "50px";
			tip.style.right = "10px";
			tip.style.zIndex = "999";
			tip.style.maxWidth = "80vw";

			const close = document.createElement("button");
			close.textContent = "‚úñ";
			close.style.marginLeft = "10px";
			close.style.cursor = "pointer";
			close.onclick = () => tip.remove();
			tip.appendChild(close);

			document.body.appendChild(tip);
		}
	</script>

	<script>
		
	</script>

</body>

</html>